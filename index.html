<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1a1a2e">
    <title>Drum Kit</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a1a2e;
        }
        
        .container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
        }
        
        .drum-wrapper {
            position: relative;
        }
        
        .drum-image {
            display: block;
        }
        
        .touch-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .drum-zone {
            pointer-events: auto;
            cursor: pointer;
            fill: transparent;
            stroke: transparent;
            transition: fill 0.15s;
        }
        
        .drum-zone:hover {
            fill: transparent;
            stroke: transparent;
        }
        
        .drum-zone.cymbal.active {
            fill: url(#cymbalGradient);
        }
        
        .drum-zone.drum.active {
            fill: url(#drumGradient);
        }
        
        .fullscreen-btn {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: background 0.2s;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        .fullscreen-btn:hover {
            background: rgba(0, 0, 0, 0.8);
        }
        
        .fullscreen-btn svg {
            width: 28px;
            height: 28px;
            fill: white;
        }
        
        .fullscreen-btn .exit-icon {
            display: none;
        }
        
        .fullscreen-btn.is-fullscreen .enter-icon {
            display: none;
        }
        
        .fullscreen-btn.is-fullscreen .exit-icon {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="drum-wrapper" id="drumWrapper">
            <img src="drum.jpg" alt="Drum Kit" class="drum-image" id="drumImage">
            <svg class="touch-layer" id="touchLayer" viewBox="0 0 1280 800" preserveAspectRatio="none">
                <defs>
                    <!-- 심벌즈/하이햇용 노란색 그라데이션 -->
                    <radialGradient id="cymbalGradient">
                        <stop offset="0%" stop-color="rgba(255, 220, 0, 0.5)"/>
                        <stop offset="100%" stop-color="rgba(255, 220, 0, 0)"/>
                    </radialGradient>
                    <!-- 드럼용 흰색 그라데이션 -->
                    <radialGradient id="drumGradient">
                        <stop offset="0%" stop-color="rgba(255, 255, 255, 0.5)"/>
                        <stop offset="100%" stop-color="rgba(255, 255, 255, 0)"/>
                    </radialGradient>
                </defs>
                
                <!-- 크래시 심벌즈 (왼쪽 상단) - 오른쪽으로 더 크게 -->
                <ellipse id="crash" class="drum-zone cymbal" data-drum="crash"
                    cx="135" cy="130" rx="215" ry="110"/>
                
                <!-- 하이-햇 (왼쪽 중간) - 오른쪽으로 이동 -->
                <ellipse id="hihat" class="drum-zone cymbal" data-drum="hihat"
                    cx="165" cy="365" rx="175" ry="90"/>
                
                <!-- 스네어 드럼 (왼쪽 하단) - 오른쪽으로 더 크게 -->
                <ellipse id="snare" class="drum-zone drum" data-drum="snare"
                    cx="255" cy="590" rx="190" ry="110"/>
                
                <!-- 하이탐 (중앙 상단 왼쪽) - 아래로 이동 -->
                <ellipse id="hitom" class="drum-zone drum" data-drum="hitom"
                    cx="478" cy="245" rx="130" ry="115"/>
                
                <!-- 미드탐 (중앙 상단 오른쪽) - 아래로 이동 -->
                <ellipse id="midtom" class="drum-zone drum" data-drum="midtom"
                    cx="785" cy="245" rx="130" ry="115"/>
                
                <!-- 베이스 드럼 (중앙) - 아래쪽 기준, 세로 줄임 -->
                <ellipse id="bass" class="drum-zone drum" data-drum="bass"
                    cx="640" cy="640" rx="185" ry="155"/>
                
                <!-- 라이드 심벌즈 (오른쪽 상단) - 아래로 이동, 더 크게 -->
                <ellipse id="ride" class="drum-zone cymbal" data-drum="ride"
                    cx="1145" cy="170" rx="215" ry="160"/>
                
                <!-- 로우탐 (오른쪽) - 오른쪽, 아래로 이동 -->
                <ellipse id="lowtom" class="drum-zone drum" data-drum="lowtom"
                    cx="1045" cy="575" rx="215" ry="130"/>
            </svg>
        </div>
    </div>
    
    <button class="fullscreen-btn" id="fullscreenBtn" title="전체화면">
        <svg class="enter-icon" viewBox="0 0 24 24">
            <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
        </svg>
        <svg class="exit-icon" viewBox="0 0 24 24">
            <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/>
        </svg>
    </button>

    <script>
        // 이미지와 SVG 레이어 크기 동기화 - 이미지 전체가 보이도록
        const drumImage = document.getElementById('drumImage');
        const touchLayer = document.getElementById('touchLayer');
        const drumWrapper = document.getElementById('drumWrapper');
        
        const IMG_WIDTH = 1280;
        const IMG_HEIGHT = 800;
        const IMG_RATIO = IMG_WIDTH / IMG_HEIGHT;
        
        function resizeDrum() {
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const windowRatio = windowWidth / windowHeight;
            
            let newWidth, newHeight;
            
            // 이미지 전체가 보이도록 계산 (contain 방식)
            if (windowRatio > IMG_RATIO) {
                // 화면이 더 넓으면 높이에 맞춤
                newHeight = windowHeight;
                newWidth = windowHeight * IMG_RATIO;
            } else {
                // 화면이 더 좁으면 너비에 맞춤
                newWidth = windowWidth;
                newHeight = windowWidth / IMG_RATIO;
            }
            
            drumWrapper.style.width = newWidth + 'px';
            drumWrapper.style.height = newHeight + 'px';
            drumImage.style.width = newWidth + 'px';
            drumImage.style.height = newHeight + 'px';
        }
        
        drumImage.addEventListener('load', resizeDrum);
        window.addEventListener('resize', resizeDrum);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeDrum, 100);
        });
        
        // 초기 로드 시 실행
        resizeDrum();
        if (drumImage.complete) {
            resizeDrum();
        }
        
        // Web Audio API 초기화
        let audioContext = null;
        const activeOscillators = new Map();
        
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }
        
        // 드럼 소리 합성 함수들
        const drumSounds = {
            // 베이스 드럼 - 깊고 강한 저음
            bass: () => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const osc2 = audioContext.createOscillator();
                const gain2 = audioContext.createGain();
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(150, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, audioContext.currentTime + 0.3);
                
                gain.gain.setValueAtTime(1.5, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.0);
                
                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(80, audioContext.currentTime);
                osc2.frequency.exponentialRampToValueAtTime(30, audioContext.currentTime + 0.2);
                
                gain2.gain.setValueAtTime(1.2, audioContext.currentTime);
                gain2.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.8);
                
                const masterGain = audioContext.createGain();
                masterGain.gain.value = 1.8;
                
                osc.connect(gain);
                osc2.connect(gain2);
                gain.connect(masterGain);
                gain2.connect(masterGain);
                masterGain.connect(audioContext.destination);
                
                osc.start();
                osc2.start();
                osc.stop(audioContext.currentTime + 1.0);
                osc2.stop(audioContext.currentTime + 0.8);
            },
            
            // 스네어 드럼 - 스냅감 있는 소리
            snare: () => {
                // 톤 부분
                const osc = audioContext.createOscillator();
                const oscGain = audioContext.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(120, audioContext.currentTime + 0.1);
                oscGain.gain.setValueAtTime(0.8, audioContext.currentTime);
                oscGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
                
                // 노이즈 부분 (스네어 와이어)
                const bufferSize = audioContext.sampleRate * 0.5;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                const noise = audioContext.createBufferSource();
                noise.buffer = buffer;
                
                const noiseFilter = audioContext.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.value = 1500;
                
                const noiseGain = audioContext.createGain();
                noiseGain.gain.setValueAtTime(1.0, audioContext.currentTime);
                noiseGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
                
                const masterGain = audioContext.createGain();
                masterGain.gain.value = 1.5;
                
                osc.connect(oscGain);
                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                oscGain.connect(masterGain);
                noiseGain.connect(masterGain);
                masterGain.connect(audioContext.destination);
                
                osc.start();
                noise.start();
                osc.stop(audioContext.currentTime + 0.3);
                noise.stop(audioContext.currentTime + 0.5);
            },
            
            // 닫힌 하이-햇
            hihat: () => {
                const bufferSize = audioContext.sampleRate * 0.3;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                const noise = audioContext.createBufferSource();
                noise.buffer = buffer;
                
                const highpass = audioContext.createBiquadFilter();
                highpass.type = 'highpass';
                highpass.frequency.value = 7000;
                
                const bandpass = audioContext.createBiquadFilter();
                bandpass.type = 'bandpass';
                bandpass.frequency.value = 10000;
                bandpass.Q.value = 1;
                
                const gain = audioContext.createGain();
                gain.gain.setValueAtTime(1.2, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.25);
                
                const masterGain = audioContext.createGain();
                masterGain.gain.value = 2.5;
                
                noise.connect(highpass);
                highpass.connect(bandpass);
                bandpass.connect(gain);
                gain.connect(masterGain);
                masterGain.connect(audioContext.destination);
                
                noise.start();
                noise.stop(audioContext.currentTime + 0.3);
            },
            
            // 크래시 심벌즈
            crash: () => {
                const bufferSize = audioContext.sampleRate * 1.5;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                const noise = audioContext.createBufferSource();
                noise.buffer = buffer;
                
                const highpass = audioContext.createBiquadFilter();
                highpass.type = 'highpass';
                highpass.frequency.value = 5000;
                
                const gain = audioContext.createGain();
                gain.gain.setValueAtTime(1.3, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.3);
                
                const masterGain = audioContext.createGain();
                masterGain.gain.value = 2.2;
                
                noise.connect(highpass);
                highpass.connect(gain);
                gain.connect(masterGain);
                masterGain.connect(audioContext.destination);
                
                noise.start();
                noise.stop(audioContext.currentTime + 1.5);
            },
            
            // 라이드 심벌즈
            ride: () => {
                const bufferSize = audioContext.sampleRate * 1.2;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                const noise = audioContext.createBufferSource();
                noise.buffer = buffer;
                
                const highpass = audioContext.createBiquadFilter();
                highpass.type = 'highpass';
                highpass.frequency.value = 6000;
                
                const bandpass = audioContext.createBiquadFilter();
                bandpass.type = 'bandpass';
                bandpass.frequency.value = 8000;
                bandpass.Q.value = 2;
                
                const gain = audioContext.createGain();
                gain.gain.setValueAtTime(1.0, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.0);
                
                // 핑 사운드 추가
                const osc = audioContext.createOscillator();
                const oscGain = audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.value = 5500;
                oscGain.gain.setValueAtTime(0.25, audioContext.currentTime);
                oscGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.6);
                
                const masterGain = audioContext.createGain();
                masterGain.gain.value = 2.2;
                
                noise.connect(highpass);
                highpass.connect(bandpass);
                bandpass.connect(gain);
                gain.connect(masterGain);
                osc.connect(oscGain);
                oscGain.connect(masterGain);
                masterGain.connect(audioContext.destination);
                
                noise.start();
                osc.start();
                noise.stop(audioContext.currentTime + 1.2);
                osc.stop(audioContext.currentTime + 0.6);
            },
            
            // 하이탐
            hitom: () => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(280, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(180, audioContext.currentTime + 0.15);
                
                gain.gain.setValueAtTime(1.0, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.6);
                
                const masterGain = audioContext.createGain();
                masterGain.gain.value = 1.5;
                
                osc.connect(gain);
                gain.connect(masterGain);
                masterGain.connect(audioContext.destination);
                
                osc.start();
                osc.stop(audioContext.currentTime + 0.6);
            },
            
            // 미드탐
            midtom: () => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(220, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(140, audioContext.currentTime + 0.18);
                
                gain.gain.setValueAtTime(1.0, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.7);
                
                const masterGain = audioContext.createGain();
                masterGain.gain.value = 1.5;
                
                osc.connect(gain);
                gain.connect(masterGain);
                masterGain.connect(audioContext.destination);
                
                osc.start();
                osc.stop(audioContext.currentTime + 0.7);
            },
            
            // 로우탐
            lowtom: () => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(160, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(90, audioContext.currentTime + 0.2);
                
                gain.gain.setValueAtTime(1.1, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.8);
                
                const masterGain = audioContext.createGain();
                masterGain.gain.value = 1.5;
                
                osc.connect(gain);
                gain.connect(masterGain);
                masterGain.connect(audioContext.destination);
                
                osc.start();
                osc.stop(audioContext.currentTime + 0.8);
            }
        };
        
        // 드럼 연주 함수
        function playDrum(drumType, element) {
            initAudio();
            if (drumSounds[drumType]) {
                drumSounds[drumType]();
                
                // 시각적 피드백
                element.classList.add('active');
                setTimeout(() => {
                    element.classList.remove('active');
                }, 100);
            }
        }
        
        // 터치/마우스 이벤트 핸들러
        const drumZones = document.querySelectorAll('.drum-zone');
        const activeTouches = new Map(); // 터치별 마지막 드럼 추적
        
        // 터치 위치에서 드럼 영역 찾기
        function getDrumAtPoint(x, y) {
            const elements = document.elementsFromPoint(x, y);
            for (let el of elements) {
                if (el.classList.contains('drum-zone')) {
                    return el;
                }
            }
            return null;
        }
        
        // 터치 시작
        document.addEventListener('touchstart', (e) => {
            e.preventDefault();
            initAudio();
            
            for (let touch of e.changedTouches) {
                const drum = getDrumAtPoint(touch.clientX, touch.clientY);
                if (drum) {
                    const drumType = drum.dataset.drum;
                    activeTouches.set(touch.identifier, drumType);
                    playDrum(drumType, drum);
                } else {
                    activeTouches.set(touch.identifier, null);
                }
            }
        }, { passive: false });
        
        // 터치 이동 (스와이프)
        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
            
            for (let touch of e.changedTouches) {
                const drum = getDrumAtPoint(touch.clientX, touch.clientY);
                const lastDrumType = activeTouches.get(touch.identifier);
                
                if (drum) {
                    const drumType = drum.dataset.drum;
                    // 새로운 드럼 영역에 진입했을 때만 소리 재생
                    if (drumType !== lastDrumType) {
                        activeTouches.set(touch.identifier, drumType);
                        playDrum(drumType, drum);
                    }
                } else {
                    activeTouches.set(touch.identifier, null);
                }
            }
        }, { passive: false });
        
        // 터치 종료
        document.addEventListener('touchend', (e) => {
            e.preventDefault();
            for (let touch of e.changedTouches) {
                activeTouches.delete(touch.identifier);
            }
        }, { passive: false });
        
        // 마우스 이벤트
        drumZones.forEach(zone => {
            zone.addEventListener('mousedown', (e) => {
                e.preventDefault();
                initAudio();
                const drumType = zone.dataset.drum;
                playDrum(drumType, zone);
            });
        });
        
        // 전체화면 기능 (모바일/태블릿 호환성 개선)
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        
        function getFullscreenElement() {
            return document.fullscreenElement || 
                   document.webkitFullscreenElement || 
                   document.mozFullScreenElement ||
                   document.msFullscreenElement;
        }
        
        function requestFullscreen(element) {
            if (element.requestFullscreen) {
                return element.requestFullscreen();
            } else if (element.webkitRequestFullscreen) {
                return element.webkitRequestFullscreen();
            } else if (element.webkitEnterFullscreen) {
                return element.webkitEnterFullscreen();
            } else if (element.mozRequestFullScreen) {
                return element.mozRequestFullScreen();
            } else if (element.msRequestFullscreen) {
                return element.msRequestFullscreen();
            }
            return Promise.reject('Fullscreen not supported');
        }
        
        function exitFullscreen() {
            if (document.exitFullscreen) {
                return document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                return document.webkitExitFullscreen();
            } else if (document.webkitCancelFullScreen) {
                return document.webkitCancelFullScreen();
            } else if (document.mozCancelFullScreen) {
                return document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) {
                return document.msExitFullscreen();
            }
            return Promise.reject('Exit fullscreen not supported');
        }
        
        function toggleFullscreen() {
            if (!getFullscreenElement()) {
                requestFullscreen(document.documentElement).catch(err => {
                    // iOS Safari는 전체화면 API를 지원하지 않음
                    // 대신 주소창을 숨기는 스크롤 트릭 사용
                    window.scrollTo(0, 1);
                    alert('이 브라우저에서는 전체화면이 지원되지 않습니다.\n\n아이패드/아이폰: Safari에서 "홈 화면에 추가"를 사용하면 전체화면으로 실행됩니다.\n\n안드로이드: Chrome 메뉴에서 "홈 화면에 추가"를 사용하세요.');
                });
            } else {
                exitFullscreen().catch(err => {
                    console.log('Exit fullscreen error:', err);
                });
            }
        }
        
        // 클릭과 터치 이벤트 모두 지원
        fullscreenBtn.addEventListener('click', toggleFullscreen);
        fullscreenBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            toggleFullscreen();
        }, { passive: false });
        
        // 전체화면 상태 변경 감지
        document.addEventListener('fullscreenchange', updateFullscreenButton);
        document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
        document.addEventListener('mozfullscreenchange', updateFullscreenButton);
        document.addEventListener('MSFullscreenChange', updateFullscreenButton);
        
        function updateFullscreenButton() {
            if (getFullscreenElement()) {
                fullscreenBtn.classList.add('is-fullscreen');
            } else {
                fullscreenBtn.classList.remove('is-fullscreen');
            }
        }
        
        // 컨텍스트 메뉴 방지
        document.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // iOS Safari에서 더블탭 줌 방지
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, { passive: false });
        
        // 오디오 컨텍스트 초기화 (첫 터치/클릭 시)
        document.addEventListener('click', initAudio, { once: true });
        document.addEventListener('touchstart', initAudio, { once: true });
    </script>
</body>
</html>
